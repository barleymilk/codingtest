package solution;

import java.io.FileInputStream;
import java.util.Scanner;
import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.Arrays;

public class Main {
	public static void main(String[] args) throws Exception {
		// BFS
		// add(value) 또는 offer(value): 큐의 맨 뒤에 데이터 넣기
		// poll(): 큐의 맨 앞을 꺼내고 반환. 큐가 비어 있으면 null 반환
		// isEmpty(): 큐가 비어있는지 확인(BFS 종료 조건으로 사용)
		
		System.setIn(new FileInputStream("res/input.txt"));
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		
		for (int tc = 1; tc <= T; tc++) {
			System.out.print(tc + " ");
			int N = sc.nextInt();
			
			Queue<Integer> queue = new LinkedList<>();
			ArrayList<Integer>[] adjList = new ArrayList[N+1];
			boolean[] visited = new boolean[N+1];
			queue.add(1);
			visited[1] = true;
			
			for (int i = 1; i <= N; i++) {
				adjList[i] = new ArrayList<>(); // 각 노드마다 리스트 생
			}
			
			int parentNode;
			for (int i = 2; i <= N; i++) {
				parentNode = sc.nextInt();
				adjList[i].add(parentNode);
				adjList[parentNode].add(i);
			}
			System.out.println(Arrays.toString(adjList));
			
			int answer = 0;
			// 큐가 비어있을 때까지 반
			while(!queue.isEmpty()) {
				// 큐에서 노드를 하나 꺼냄 
				int curr = queue.poll();
				System.out.println("curr: " + curr);
				
				// 인접한 노드 중 방문하지 않은 노드를 모두 큐에 넣음 
				for (int neighbor: adjList[curr]) {
					if(!visited[neighbor]) {
						queue.add(neighbor);
						visited[neighbor] = true;
					}
				}
			}
			
			System.out.println("#" + tc + " " + answer);
			System.out.println(Arrays.toString(visited));
			System.out.println();
			
		}
		
	}

}
